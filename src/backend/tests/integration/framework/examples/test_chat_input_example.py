"""Example of ChatInput integration test using new framework."""

from langflow.components.input_output import ChatInput

from tests.integration.framework import ComponentTest, leak_detection, timeout


class TestChatInputExample(ComponentTest):
    """Example test for ChatInput using new framework."""

    component_class = ChatInput

    # Optional: customize default inputs
    default_inputs = {"sender": "User", "sender_name": "Test User"}

    async def test_basic_functionality(self):
        """Test basic ChatInput functionality."""
        result = await self.run_component(run_input="Hello World")

        # Use built-in assertion helpers
        self.assert_message_output(result, "Hello World")
        self.assert_output_type(result, "message", Message)

    async def test_empty_input(self):
        """Test ChatInput with empty input."""
        result = await self.run_component(run_input="")

        self.assert_message_output(result, "")

        # Access message directly for detailed assertions
        message = result["message"]
        assert message.sender == "User"
        assert message.sender_name == "Test User"

    async def test_custom_sender(self):
        """Test ChatInput with custom sender."""
        result = await self.run_component(inputs={"sender": "Bot", "sender_name": "Assistant"}, run_input="Bot message")

        # Use assertion helpers for complex checks
        self.assertions.assert_message(result["message"], expected_text="Bot message", expected_sender="Bot")

    @timeout(5.0)
    async def test_performance(self):
        """Test ChatInput performance."""
        import time

        start_time = time.time()
        result = await self.run_component(run_input="Performance test")
        execution_time = time.time() - start_time

        # Use performance assertion helper
        self.assertions.assert_performance(execution_time, max_time=1.0, operation_name="ChatInput execution")

        self.assert_message_output(result, "Performance test")

    async def test_message_storage(self):
        """Test message storage functionality."""
        # Test with storage enabled
        session_id = "test-session-storage"
        result = await self.run_component(
            inputs={"should_store_message": True}, run_input="Stored message", session_id=session_id
        )

        self.assert_message_output(result, "Stored message")

        # Verify message was stored (would need memory import)
        # from langflow.memory import aget_messages
        # stored_messages = await aget_messages(session_id=session_id)
        # assert len(stored_messages) == 1

    async def test_input_validation(self):
        """Test input parameter validation."""
        # Test valid inputs
        valid_inputs = [
            {"sender": "User", "sender_name": "John"},
            {"sender": "Bot", "sender_name": "Assistant"},
            {"sender": "System", "sender_name": "System"},
        ]

        for inputs in valid_inputs:
            result = await self.run_component(inputs=inputs, run_input="Test message")

            message = result["message"]
            assert message.sender == inputs["sender"]
            assert message.sender_name == inputs["sender_name"]

    @leak_detection()
    async def test_memory_usage(self):
        """Test that ChatInput doesn't leak memory."""
        # Run multiple times to detect leaks
        for i in range(50):
            result = await self.run_component(run_input=f"Message {i}")
            self.assert_message_output(result, f"Message {i}")

    async def test_component_contract(self):
        """Test that component follows expected contract."""
        component = self.component_instance

        # Use built-in contract assertion
        self.assertions.assert_component_contract(
            component,
            expected_inputs=["input_value", "sender", "sender_name", "should_store_message"],
            expected_outputs=["message"],
            required_attributes=["display_name", "description"],
        )

        # Additional contract checks
        assert component.display_name == "Chat Input"
        assert "input from the user" in component.description.lower()


# Example of how to use auto-generation decorator
from tests.integration.framework.base import auto_component_test


@auto_component_test(ChatInput)
class TestChatInputAutoGenerated(ComponentTest):
    """Auto-generated basic tests for ChatInput."""

    # Basic tests are automatically added by the decorator
    # You can still add custom tests here

    async def test_custom_behavior(self):
        """Custom test beyond auto-generated ones."""
        result = await self.run_component(run_input="Custom test")
        self.assert_message_output(result, "Custom test")


# Example of parameterized testing
import pytest


class TestChatInputParameterized(ComponentTest):
    """Parameterized tests for ChatInput."""

    component_class = ChatInput

    @pytest.mark.parametrize(
        ("input_text", "expected_text"),
        [
            ("hello", "hello"),
            ("", ""),
            ("Multi\nline\ntext", "Multi\nline\ntext"),
            ("Special chars: !@#$%^&*()", "Special chars: !@#$%^&*()"),
            ("Unicode: ‰Ω†Â•Ω üåç", "Unicode: ‰Ω†Â•Ω üåç"),
        ],
    )
    async def test_various_inputs(self, input_text, expected_text):
        """Test ChatInput with various input types."""
        result = await self.run_component(run_input=input_text)
        self.assert_message_output(result, expected_text)

    @pytest.mark.parametrize(
        ("sender", "sender_name"), [("User", "John Doe"), ("Bot", "Assistant"), ("System", "System"), ("AI", "GPT-4")]
    )
    async def test_sender_configurations(self, sender, sender_name):
        """Test different sender configurations."""
        result = await self.run_component(
            inputs={"sender": sender, "sender_name": sender_name}, run_input="Test message"
        )

        message = result["message"]
        assert message.sender == sender
        assert message.sender_name == sender_name
